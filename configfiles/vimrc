set nocompatible
syntax enable

call plug#begin('~/.config/nvim/plugged')

Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'benekastah/neomake'
Plug 'kassio/neoterm'

Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'mileszs/ack.vim'

Plug 'itchyny/lightline.vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-eunuch'

Plug 'jiangmiao/auto-pairs'

Plug 'christoomey/vim-tmux-navigator'
Plug 'epeli/slimux'

Plug 'simnalamburt/vim-mundo'
Plug 'godlygeek/tabular'
Plug 'Wolfy87/vim-expand'

Plug 'mattn/emmet-vim'
Plug 'wellle/targets.vim'

Plug 'elixir-lang/vim-elixir', { 'for': ['elixir', 'eelixir'] }
Plug 'slashmili/alchemist.vim', { 'for': ['elixir', 'eelixir'] }
Plug 'powerman/vim-plugin-AnsiEsc'

Plug 'Shougo/vimproc.vim', {'do' : 'make'}

Plug 'fatih/vim-go', { 'for': 'go' }
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
Plug 'othree/yajs.vim', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'gavocanov/vim-js-indent', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'mxw/vim-jsx', { 'for': 'javascript.jsx' }
Plug 'flowtype/vim-flow', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'leafgarland/typescript-vim'
Plug 'ElmCast/elm-vim', { 'for': 'elm' }
Plug 'raichoo/purescript-vim', { 'for': 'purescript' }
Plug 'guns/vim-clojure-static', { 'for': 'clojure' }
Plug 'eagletmt/ghcmod-vim', { 'for': 'haskell' }
Plug 'eagletmt/neco-ghc', { 'for': 'haskell' }
Plug 'idris-hackers/idris-vim'
Plug 'reasonml/vim-reason'
Plug 'tpope/vim-fireplace'
Plug 'kovisoft/paredit'

Plug 'justinmk/vim-dirvish'
Plug 'flazz/vim-colorschemes'
Plug 'ekalinin/Dockerfile.vim'
Plug 'janko-m/vim-test'

Plug 'SirVer/ultisnips', { 'on': [] }

" ultisnips is slow to load, so defer until going into insert mode
augroup load_ultisnips
  autocmd!
  autocmd InsertEnter * call plug#load('ultisnips') | autocmd! load_ultisnips
augroup END

call plug#end()

filetype plugin indent on     " required!

let $TERM='xterm-256color'
let $NVIM_TUI_ENABLE_TRUE_COLOR=1

if has('termguicolors')
  set termguicolors
endif

" Workaround for C-h not working with vim-tmux-navigator in neovim
if has('nvim')
  nnoremap <silent> <BS> :TmuxNavigateLeft<cr>
endif

" Turn on cursorline only on active window
augroup MyAutoCmd
  autocmd!
  autocmd WinLeave * setlocal nocursorline
  autocmd WinEnter,BufRead * setlocal cursorline
augroup END

set autoread
set background=dark
set backspace=indent,eol,start
set backup
set backupdir=~/.config/nvim/backup/
set directory=~/.config/nvim/swap/
set clipboard=unnamed
set complete-=i
set completeopt=menuone,longest
set cursorline
set expandtab
set hidden
set history=1000
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set lazyredraw
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<
set nojoinspaces
set nomodeline
set nrformats-=octal
set number
set path+=**
set ruler
set scrolloff=3
set shiftwidth=2
set showcmd
set showmatch
set smartcase
set smartindent
set smarttab
set splitbelow
set splitright
set switchbuf=useopen
set tabstop=2
set ttimeoutlen=50
set wildignorecase
set wildmenu
set wildmode=longest,full

" Enter key selects menu item
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"
" Select an item by default
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
  \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-l> pumvisible() ? '<C-x><C-l>' :
  \ '<C-x><C-l><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-o> pumvisible() ? '<C-x><C-o>' :
  \ '<C-x><C-o><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

inoremap <c-e> <c-o>$
inoremap <c-a> <c-o>0

let mapleader="\<Space>"

nnoremap j gj
nnoremap k gk

" Useful shortcuts for working with splits
nnoremap <silent> <Leader>h :sp<cr>
nnoremap <silent> <Leader>v :vsp<cr>
map <S-up> 2<C-w>+
map <S-down> 2<C-w>-
map <S-left> 4<C-w><
map <S-right> 4<C-w>>

nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR>
nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
nnoremap <silent> <Leader>> :exe "vertical resize " . (winwidth(0) * 3/2)<CR>
nnoremap <silent> <Leader>< :exe "vertical resize " . (winwidth(0) * 2/3)<CR>

" Don't use Ex mode, use Q for formatting
map Q gq
" Make Y follow the same pattern as C and D
map Y y$

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
inoremap <C-j> <Esc>
nnoremap <leader>s :mksession<CR>

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" run GoImports on write
autocmd BufWritePre *.go call go#fmt#Format(1)

" turn off showmatch for rust (beeps on >)
autocmd filetype rust setlocal noshowmatch

"put these in an autocmd group, so that we can delete them easily.
augroup vimrcex
  autocmd!

  " for all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78
  autocmd BufLeave *.css,*.less,*scss normal! mC
  autocmd BufLeave *.html             normal! mH
  autocmd BufLeave *.js               normal! mJ

  autocmd VimEnter * nested colorscheme jellybeans

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif

augroup end

function! ToggleLintOnSave()
  if exists('#javascript_lint#BufWritePost')
    augroup javascript_lint
      autocmd! BufWritePost *.js
    augroup end
    echom 'Linting on save disabled'
    sign unplace *
  else
    augroup javascript_lint
      autocmd! BufWritePost *.js Neomake
    augroup end
    echom 'Linting on save enabled'
  endif
endfunction

command! ToggleLintOnSave :call ToggleLintOnSave()

nmap <silent> <leader>tn :TestNearest<CR>
nmap <silent> <leader>tf :TestFile<CR>
nmap <silent> <leader>ts :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tv :TestVisit<CR>
let test#strategy = 'neoterm'

let g:test#javascript#mocha#executable = 'npm test -- '

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

nnoremap <leader>rd :DiffOrig<CR>
nnoremap <leader>re :edit $MYVIMRC<CR>
nnoremap <leader>rs :source $MYVIMRC<CR>
nnoremap <leader>rw <C-w>x

let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename'] ],
      \   'right': [ [ 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightLineFugitive',
      \   'filename': 'LightLineFilename',
      \   'fileformat': 'LightLineFileformat',
      \   'filetype': 'LightLineFiletype',
      \   'fileencoding': 'LightLineFileencoding',
      \   'mode': 'LightLineMode'
      \ }
      \ }

function! LightLineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightLineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname =~ '__Mundo\|NERD_tree' ? '' :
        \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Mundo\|NERD' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
  let fname = expand('%:t')
  return  fname == '__Mundo__' ? 'Mundo' :
        \ fname == '__Mundo_Preview__' ? 'Mundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

let g:ctrlp_status_func = {
      \ 'main': 'CtrlPStatusFunc_1',
      \ 'prog': 'CtrlPStatusFunc_2',
      \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

nnoremap <leader><Space> :nohlsearch<CR>

imap <C-Y>s <Plug>snipMateNextOrTrigger
smap <C-Y>s <Plug>snipMateNextOrTrigger
let user_emmet_expandabbr_key = '<C-Y>y'
" custom emmet expander to split tags and open line between
imap <C-Y>o <C-Y>y<CR><C-o>O<C-i>

let g:ctrlp_open_new_file = 'r'

if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor
endif

" dir path for current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%

" change current directory to that of the current file
nmap <leader>cd :cd %:p:h<CR>

nnoremap <leader>u :MundoToggle<CR>

nnoremap <leader>q :ccl<CR>

function! StripWhitespace()
  let save_cursor = getpos(".")
  let old_query = getreg('/')
  :%s/\s\+$//e
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>w :call StripWhitespace()<CR>

let g:ctrlp_max_height = 30

" Change default HTML indentation to include more tags
let g:html_indent_inctags = "html,body,head,tbody,p"

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="horizontal"
nnoremap <leader>sn :UltiSnipsEdit<CR>

command! Snips :call UltiSnips#ListSnippets()

nmap <C-c><C-c> :SlimuxREPLSendLine<CR>
vmap <C-c><C-c> :SlimuxREPLSendSelection<CR>

augroup GoAwayPreviewWindow
  autocmd! InsertLeave * wincmd z
augroup END

" enable the vim-vinegar features that I like
let g:netrw_banner = 0
let g:netrw_list_hide='^\.\/'
let g:netrw_altfile=1
let g:netrw_liststyle=1

let g:NERDTreeHijackNetrw=0
nnoremap <leader>n :NERDTreeToggle<CR>

nnoremap - :Dirvish %:p:h<CR>

function! SetTestDirs(src_dir, test_dir, src_ext, test_post, test_ext)
  let b:src_dir = a:src_dir
  let b:test_dir = a:test_dir
  let b:src_ext = a:src_ext
  let b:test_post = a:test_post
  let b:test_ext = a:test_ext
endfunction

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

map <leader>rf :call RenameFile()<cr>

let g:jsx_ext_required = 0

nnoremap <leader>el :ElmEvalLine<CR>
vnoremap <leader>es :<C-u>ElmEvalSelection<CR>
nnoremap <leader>em :ElmMakeCurrentFile<CR>

" set path for gf when working with require in Node
function! Nodegf()
python << EOF
import os
import sys
import vim

vim.command(r"set suffixesadd+=.js")

# walk up and check every folder for node_modules folder,
# and if found add it to the path
current_folder = os.path.dirname(vim.eval("expand('%:p')"))
while current_folder is not "/":
	current = os.path.join(current_folder, 'node_modules')
	if os.path.exists(current):
		vim.command(r"set path+=%s" % (current.replace(" ", r"\ ")))
	current_folder = os.path.abspath(os.path.join(current_folder, '..'))
EOF
endfunction

augroup Node
  autocmd!
  autocmd filetype javascript :call Nodegf()
  autocmd filetype javascript.jsx :call Nodegf()
augroup END

let g:neomake_javascript_enabled_makers = ['eslint']

let g:projectionist_heuristics = {
  \ "package.json": {
    \ "src/*.js": {
    \   "alternate": "test/{}.spec.js"
    \ },
    \ "test/*.spec.js": {
    \   "alternate": "src/{}.js"
    \ }
  \ },
  \ "Cargo.toml": {
    \ "src/*.rs": {
    \   "alternate": "tests/{}.rs"
    \ },
    \ "tests/*.rs": {
    \   "alternate": "src/{}.rs"
    \ }
  \ },
  \ "mix.exs": {
    \ "lib/*.ex": {
    \   "alternate": "test/{}_test.exs"
    \ },
    \ "web/channels/*_channel.ex": {
    \   "alternate": "test/channels/{}_channel_test.exs"
    \ },
    \ "web/controllers/*_controller.ex": {
    \   "alternate": "test/controllers/{}_controller_test.exs"
    \ },
    \ "web/views/*_view.ex": {
    \   "alternate": "test/views/{}_view_test.exs"
    \ },
    \ "web/models/*.ex": {
    \   "alternate": "test/models/{}_test.exs"
    \ },
    \ "test/*_test.exs": {
    \   "alternate": "lib/{}.ex"
    \ },
    \ "test/channels/*_channel_test.exs": {
    \   "alternate": "web/channels/{}_channel.ex"
    \ },
    \ "test/controllers/*_controller_test.exs": {
    \   "alternate": "web/controllers/{}_controller.ex"
    \ },
    \ "test/views/*_view_test.exs": {
    \   "alternate": "web/views/{}_view.ex"
    \ },
    \ "test/models/*_test.exs": {
    \   "alternate": "web/models/{}.ex"
    \ },
    \ "web/static/js/src/*.js": {
    \   "alternate": "test/{}.spec.js"
    \ },
    \ "web/static/js/test/*.spec.js": {
    \   "alternate": "src/{}.js"
    \ }
\   }
\ }

let g:flow#enable = 0
nmap <leader>fm :FlowMake<cr>
nmap <leader>ft :FlowType<cr>
nmap <leader>fo :FlowToggle<cr>

nmap <leader>tw :GhcModTypeInsert<CR>
nmap <leader>ts :GhcModSplitFunCase<CR>
nmap <leader>tq :GhcModType<CR>
nmap <leader>te :GhcModTypeClear<CR>

augroup Haskell
  autocmd!
  autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
augroup END

vmap a= :Tabularize /=<CR>
vmap a; :Tabularize /::<CR>
vmap a- :Tabularize /-><CR>

" replace word under cursor with last yank
nmap <leader>p viw"0p

" FZF mappings
nmap <C-p> :FZF<cr>
nmap <leader>m :History<cr>
nmap <leader>b :Buffers<cr>
nmap <leader>a :Files<cr>

let g:elm_setup_keybindings = 0

if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

cnoreabbrev Ag Ack
