set nocompatible
syntax enable

call plug#begin('~/.config/nvim/plugged')

Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'benekastah/neomake'
Plug 'rking/ag.vim'
Plug 'ctrlpvim/ctrlp.vim'

Plug 'itchyny/lightline.vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-tbone'

Plug 'simnalamburt/vim-mundo'
Plug 'godlygeek/tabular'
Plug 'christoomey/vim-tmux-navigator'
Plug 'jpalardy/vim-slime'
Plug 'Wolfy87/vim-expand'

Plug 'mattn/emmet-vim'
Plug 'wellle/targets.vim'

Plug 'elixir-lang/vim-elixir'
Plug 'fatih/vim-go'
Plug 'rust-lang/rust.vim'
Plug 'pangloss/vim-javascript'
Plug 'mxw/vim-jsx'
Plug 'leafgarland/typescript-vim'
Plug 'lambdatoast/elm.vim'
Plug 'raichoo/purescript-vim'
Plug 'guns/vim-clojure-static'

Plug 'tpope/vim-fireplace'
Plug 'kovisoft/paredit'

Plug 'justinmk/vim-dirvish'
Plug 'flazz/vim-colorschemes'

Plug 'janko-m/vim-test'

Plug 'SirVer/ultisnips', { 'on': [] }

" ultisnips is slow to load, so defer until going into insert mode
augroup load_ultisnips
  autocmd!
  autocmd InsertEnter * call plug#load('ultisnips') | autocmd! load_ultisnips
augroup END

call plug#end()

filetype plugin indent on     " required!

" Turn on cursorline only on active window
augroup MyAutoCmd
  autocmd!
  autocmd WinLeave * setlocal nocursorline
  autocmd WinEnter,BufRead * setlocal cursorline
augroup END

set autoread
set background=dark
set backspace=indent,eol,start
set backup
set backupdir=~/.config/nvim/backup/
set clipboard=unnamed
set complete-=i
set completeopt=menuone,longest
set cursorline
set directory=~/.config/nvim/swap/
set expandtab
set hidden
set history=1000
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set lazyredraw
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<
set nojoinspaces
set nomodeline
set nrformats-=octal
set number
set ruler
set scrolloff=3
set shiftwidth=2
set showcmd
set showmatch
set smartcase
set smartindent
set smarttab
set splitbelow
set splitright
set switchbuf=useopen
set tabstop=2
set ttimeoutlen=50
set wildignorecase
set wildmenu
set wildmode=longest,full


" Enter key selects menu item
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"
" Select an item by default
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
  \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-l> pumvisible() ? '<C-x><C-l>' :
  \ '<C-x><C-l><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-o> pumvisible() ? '<C-x><C-o>' :
  \ '<C-x><C-o><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

inoremap <c-e> <c-o>$
inoremap <c-a> <c-o>0

let mapleader=","
nnoremap <Leader>, ,

nnoremap j gj
nnoremap k gk

" Useful shortcuts for working with splits
nnoremap <silent> <Leader>h :sp<cr>
nnoremap <silent> <Leader>v :vsp<cr>
map <S-up> 2<C-w>+
map <S-down> 2<C-w>-
map <S-left> 4<C-w><
map <S-right> 4<C-w>>

nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR>
nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
nnoremap <silent> <Leader>> :exe "vertical resize " . (winwidth(0) * 3/2)<CR>
nnoremap <silent> <Leader>< :exe "vertical resize " . (winwidth(0) * 2/3)<CR>

" Don't use Ex mode, use Q for formatting
map Q gq
" Make Y follow the same pattern as C and D
map Y y$

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>

nnoremap <leader>s :mksession<CR>

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" run GoImports on write
autocmd BufWritePre *.go call go#fmt#Format(1)

" turn off showmatch for rust (beeps on >)
autocmd filetype rust setlocal noshowmatch

"put these in an autocmd group, so that we can delete them easily.
augroup vimrcex
  autocmd!

  " for all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78
  autocmd BufEnter *.js :call SetTestDirs('src', 'test', '.js', '', '.spec.js')
  autocmd BufEnter *.ex,*exs :call SetTestDirs('lib', 'test', '.ex', '_test', '.exs')
  autocmd BufEnter *.rs :call SetTestDirs('src', 'tests', '.rs', '', '.rs')
  autocmd BufEnter *.ex,*exs,*eex nnoremap <leader>b :w\|:!mix compile<cr>
  autocmd BufEnter *.ex,*exs,*eex nnoremap <leader>d :w\|:!mix deps.get<cr>
  autocmd BufLeave *.ex,*exs,*eex nunmap <leader>b
  autocmd BufLeave *.ex,*exs,*eex nunmap <leader>d
  autocmd BufLeave *.css,*.less,*scss normal! mC
  autocmd BufLeave *.html             normal! mH
  autocmd BufLeave *.js               normal! mJ

  autocmd VimEnter * nested colorscheme jellybeans

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif

augroup END

nmap <silent> <leader>tn :TestNearest<CR>
nmap <silent> <leader>tf :TestFile<CR>
nmap <silent> <leader>ts :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tv :TestVisit<CR>

let g:test#javascript#mocha#executable = 'npm test -- '

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

nnoremap <leader>rd :DiffOrig<CR>
nnoremap <leader>re :edit $MYVIMRC<CR>
nnoremap <leader>rs :source $MYVIMRC<CR>
nnoremap <leader>rw <C-w>x

let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename'] ],
      \   'right': [ [ 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightLineFugitive',
      \   'filename': 'LightLineFilename',
      \   'fileformat': 'LightLineFileformat',
      \   'filetype': 'LightLineFiletype',
      \   'fileencoding': 'LightLineFileencoding',
      \   'mode': 'LightLineMode'
      \ }
      \ }

function! LightLineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightLineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
  let fname = expand('%:t')
  return fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

let g:ctrlp_status_func = {
      \ 'main': 'CtrlPStatusFunc_1',
      \ 'prog': 'CtrlPStatusFunc_2',
      \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

nnoremap <space> :nohlsearch<CR>

imap <C-Y>s <Plug>snipMateNextOrTrigger
smap <C-Y>s <Plug>snipMateNextOrTrigger
let user_emmet_expandabbr_key = '<C-Y>y'

let g:ctrlp_open_new_file = 'r'

if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

nmap <leader>m :CtrlPMRU<CR>
nmap <leader>gb :CtrlPBuffer<CR>
nmap <leader>ga :CtrlP<CR>

" dir path for current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%

" change current directory to that of the current file
nmap <leader>cd :cd %:p:h<CR>

nnoremap <leader>u :GundoToggle<CR>

nnoremap <leader>q :ccl<CR>

function! StripWhitespace()
  let save_cursor = getpos(".")
  let old_query = getreg('/')
  :%s/\s\+$//e
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>w :call StripWhitespace()<CR>

let g:ctrlp_max_height = 30

" Change default HTML indentation to include more tags
let g:html_indent_inctags = "html,body,head,tbody,p"

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="horizontal"
nnoremap <leader>sn :UltiSnipsEdit<CR>

command! Snips :call UltiSnips#ListSnippets()

let g:slime_target = "tmux"

function! TmuxSendKeys(command, window)
  call system("tmux send-keys -t" . a:window . " '" . a:command . "' C-m")
endfunction

augroup GoAwayPreviewWindow
  autocmd! InsertLeave * wincmd z
augroup END

" enable the vim-vinegar features that I like
let g:netrw_banner = 0
let g:netrw_list_hide='^\.\/'
let g:netrw_altfile=1
let g:netrw_liststyle=1

let g:NERDTreeHijackNetrw=0
nnoremap <leader>n :NERDTreeToggle<CR>

nnoremap - :Dirvish %:p:h<CR>

function! SwitchToTest()
  let l:root = expand('%:h')
  if l:root =~ b:test_dir
    execute 'edit ' . substitute(l:root, b:test_dir, b:src_dir, '')
          \. '/' . substitute(expand('%:t:r:r'), b:test_post, '', '') . b:src_ext
  else
    execute 'edit ' . substitute(l:root, b:src_dir, b:test_dir, '')
          \. '/' . expand('%:t:r:r'). b:test_post . b:test_ext
  endif
endfunction
command! A :call SwitchToTest()

function! SetTestDirs(src_dir, test_dir, src_ext, test_post, test_ext)
  let b:src_dir = a:src_dir
  let b:test_dir = a:test_dir
  let b:src_ext = a:src_ext
  let b:test_post = a:test_post
  let b:test_ext = a:test_ext
endfunction

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

map <leader>rf :call RenameFile()<cr>

let g:jsx_ext_required = 0

nnoremap <leader>el :ElmEvalLine<CR>
vnoremap <leader>es :<C-u>ElmEvalSelection<CR>
nnoremap <leader>em :ElmMakeCurrentFile<CR>

" set path for gf when working with require in Node
function! Nodegf()
python << EOF
import os
import sys
import vim

vim.command(r"set suffixesadd+=.js")

# walk up and check every folder for node_modules folder,
# and if found add it to the path
current_folder = os.path.dirname(vim.eval("expand('%:p')"))
while current_folder is not "/":
	# print "Will check " + current_folder
	current = os.path.join(current_folder, 'node_modules')
	if os.path.exists(current):
		# print "Will add " + current
		vim.command(r"set path+=%s" % (current.replace(" ", r"\ ")))
	current_folder = os.path.abspath(os.path.join(current_folder, '..'))

EOF
endfunction

augroup Node
  autocmd!
  autocmd filetype javascript :call Nodegf()
augroup END



" Open tmux split beneath in cwd below current pane
command! -nargs=0 Spwd exe 'Tmux split-window -l 12 -c '.shellescape(getcwd())
