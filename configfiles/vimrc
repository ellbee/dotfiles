" Use Vim settings, rather then Vi settings (much better!).
set nocompatible

set rtp+=~/.vim/bundle/neobundle.vim

call neobundle#begin(expand('~/.vim/bundle/'))

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'ctrlpvim/ctrlp.vim'

NeoBundle 'bling/vim-airline'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-surround'
NeoBundle 'tpope/vim-unimpaired'
NeoBundle 'tpope/vim-repeat'

NeoBundle 'simnalamburt/vim-mundo'
NeoBundle 'godlygeek/tabular'
NeoBundle 'christoomey/vim-tmux-navigator'
NeoBundle 'jpalardy/vim-slime'
NeoBundle 'Wolfy87/vim-expand'

NeoBundle 'tpope/vim-fireplace'
NeoBundle 'guns/vim-clojure-static'
NeoBundle 'vim-scripts/paredit.vim'

NeoBundle 'mattn/emmet-vim'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'nanotech/jellybeans.vim'
NeoBundle 'chriskempson/vim-tomorrow-theme'

NeoBundle 'fatih/vim-go'
NeoBundle 'rust-lang/rust.vim'

NeoBundle 'sirVer/ultisnips'
NeoBundle 'honza/vim-snippets'

NeoBundle 'pangloss/vim-javascript'
NeoBundle 'mxw/vim-jsx'

NeoBundle 'lambdatoast/elm.vim'

call neobundle#end()

filetype plugin indent on     " required!

NeoBundleCheck

" Set augroup
augroup MyAutoCmd
  autocmd!
augroup END

" allow backspacing over everything in insert mode
set backspace=indent,eol,start
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<
set backup		" keep a backup file
set nomodeline
set hlsearch
set history=1000		" keep 50 lines of command line history
set ruler		" show the cursor position all the time
set showcmd		" display incomplete commands
set incsearch		" do incremental searching
set shiftwidth=2
set tabstop=2
set number
set expandtab
set hidden
set laststatus=2
set cursorline
set scrolloff=3
set ignorecase
set smartcase
set smartindent
set smarttab
set showcmd
set showmatch
set switchbuf=useopen
set wildignorecase
set wildmenu
set wildmode=longest,full
set clipboard=unnamed
set splitbelow
set splitright
set completeopt=menuone,longest
set backupdir=~/.vim/backup/
set directory=~/.vim/swap/
set nojoinspaces
set autoread
set t_Co=256

if has('gui_running')
  set guifont=Inconsolata\ for\ Powerline:h15
  set timeout
  set timeoutlen=500
else
  set ttimeoutlen=50
endif

"enter key selects menu item
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"
"select an item by default
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
  \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-l> pumvisible() ? '<C-x><C-l>' :
  \ '<C-x><C-l><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-x><C-o> pumvisible() ? '<C-x><C-o>' :
  \ '<C-x><C-o><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

let mapleader=","
nnoremap <Leader>, ,

nnoremap j gj
nnoremap k gk

" Useful shortcuts for working with splits
nnoremap <silent> <Leader>h :sp<cr>
nnoremap <silent> <Leader>v :vsp<cr>
map <S-up> 2<C-w>+
map <S-down> 2<C-w>-
map <S-left> 4<C-w><
map <S-right> 4<C-w>>

nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR>
nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
nnoremap <silent> <Leader>> :exe "vertical resize " . (winwidth(0) * 3/2)<CR>
nnoremap <silent> <Leader>< :exe "vertical resize " . (winwidth(0) * 2/3)<CR>

" Don't use Ex mode, use Q for formatting
map Q gq
" Make Y follow the same pattern as C and D
map Y y$

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

"run GoImports on write
autocmd BufWritePre *.go call go#fmt#Format(1)

"turn off showmatch for rust (beeps on >)
autocmd filetype rust setlocal noshowmatch

"put these in an autocmd group, so that we can delete them easily.
augroup vimrcex
  autocmd!

  " for all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78
  autocmd BufEnter *.hs set formatprg=pointfree

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif

augroup END

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

nnoremap <leader>re :edit $MYVIMRC<CR>
nnoremap <leader>rs :source $MYVIMRC<CR>
nnoremap <leader>rn :set relativenumber!<CR>
nnoremap <leader>rw <C-w>x
inoremap <C-j> <Esc>

syntax enable

set background=dark
if $vim_color == ""
  colorscheme solarized
else
  colorscheme $vim_color
endif

nnoremap <space> :nohlsearch<CR>

let g:syntastic_javascript_checkers = ['eslint']

imap <C-Y>s <Plug>snipMateNextOrTrigger
smap <C-Y>s <Plug>snipMateNextOrTrigger
let user_emmet_expandabbr_key = '<C-Y>y'

let g:ctrlp_open_new_file = 'r'
let g:ctrlp_open_dir = '.'

function! CtrlPOpen()
  exec ':CtrlP ' . g:ctrlp_open_dir
endfunction

function! CtrlPSetDir()
  let g:ctrlp_open_dir = expand('%:p:h')
endfunction

nmap <leader>m :CtrlPMRU<CR>
nmap <leader>gb :CtrlPBuffer<CR>
nmap <leader>ga :call CtrlPOpen()<CR>
nmap <silent> <leader>gh :call CtrlPSetDir()<CR>

" dir path for current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%

" change current directory to that of the current file
nmap <leader>cd :cd %:p:h<CR>

nnoremap <leader>u :GundoToggle<CR>
nnoremap <silent> <leader>. :set hlsearch!<cr>

function! StripWhitespace()
  let save_cursor = getpos(".")
  let old_query = getreg('/')
  :%s/\s\+$//e
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>w :call StripWhitespace()<CR>

let g:ctrlp_max_height = 30

" Change default HTML indentation to include more tags
let g:html_indent_inctags = "html,body,head,tbody,p"

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="horizontal"
nnoremap <leader>sn :UltiSnipsEdit<CR>

command! Snips :call UltiSnips#ListSnippets()

let g:slime_target = "tmux"

function! TmuxSendKeys(command, window)
  call system("tmux send-keys -t" . a:window . " '" . a:command . "' C-m")
endfunction

augroup GoAwayPreviewWindow
  autocmd! InsertLeave * wincmd z
augroup END

" enable the vim-vinegar features that I like
let g:netrw_banner = 0
nnoremap - :Explore<CR>
let g:netrw_list_hide='^\.\/'
let g:netrw_altfile=1
let g:netrw_liststyle=1
autocmd FileType netrw nnoremap <buffer>gg :Rex<CR>

nnoremap <leader>n :NERDTreeToggle<CR>


function! SwitchToTest()
  let b:root = expand('%:r:r')
  let b:ext1 = expand('%:e')
  let b:ext2 = expand('%:e:e')
  if b:ext2 != b:ext1
    execute 'edit ' . substitute(b:root, 'test', 'src', '') . '.' . b:ext1
  else
    execute 'edit ' . substitute(b:root, 'src', 'test', '') . '.spec.' . b:ext1
  endif
endfunction

command! A :call SwitchToTest()

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

map <leader>rf :call RenameFile()<cr>

function! Ack(args)
 let grepprg_bak=&grepprg
 set grepprg=ack\ -H\ --nocolor\ --nogroup
 execute ":silent grep " . a:args
 execute ":redraw!"
 let &grepprg=grepprg_bak
endfunction

command! -nargs=* -complete=file Ack call Ack(<q-args>)

" settings for vim-jsx
let g:jsx_pragma_required = 0
let g:jsx_ext_required = 0

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

" unicode symbols
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.branch = '⎇'
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '∥'
let g:airline_symbols.whitespace = 'Ξ'

" powerline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = ''

let g:syntastic_haskell_ghc_mod_args = '-g -fno-warn-unused-binds'
nnoremap <leader>sc :SyntasticCheck<cr>
nnoremap <leader>st :SyntasticToggleMode<cr>
nnoremap <leader>se :Errors<cr>

nnoremap <leader>el :ElmEvalLine<CR>
vnoremap <leader>es :<C-u>ElmEvalSelection<CR>
nnoremap <leader>em :ElmMakeCurrentFile<CR>

"set path for gf when working with require in Node
function! Nodegf()
python << EOF
import os
import sys
import vim

vim.command(r"set suffixesadd+=.js")

#
# walk up and check every folder for node_modules folder,
# and if found add it to the path
#
current_folder = os.path.dirname(vim.eval("expand('%:p')"))
while current_folder is not "/":
	# print "Will check " + current_folder
	current = os.path.join(current_folder, 'node_modules')
	if os.path.exists(current):
		# print "Will add " + current
		vim.command(r"set path+=%s" % (current.replace(" ", r"\ ")))
	current_folder = os.path.abspath(os.path.join(current_folder, '..'))

EOF
endfunction

augroup Node
  autocmd!
  autocmd filetype javascript :call Nodegf()
augroup END
